#![allow(unused_parens)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

use super::*;
use rand::prelude::*;
use rusqlite::{Connection, Result};
use tiny_http::{Response, Server};
use urlencoding::decode;

macro_rules! Fail {
    ($a:expr) => {
        unsafe {
            MessageBoxA(None, s!($a), s!("Error!"), MB_OK | MB_ICONERROR);
        }
    };
}

macro_rules! FailU {
    ($a:expr) => {
        MessageBoxA(None, s!($a), s!("Error!"), MB_OK | MB_ICONERROR);
    };
}

/// Our "web service" to handle internal database requests
///
/// The server is a blocking server, so it only accepts a single request at a time.
/// A large part of this is because sqlite, while seemingly okay with concurrent reads, most definately
/// does not like concurrent writes.
//
pub fn mem_db() {
    let server = Server::http(HOST).unwrap_or_else(|_| panic!("{}{}{}", "Setting up the internal HTTP server (", HOST, ") failed.ðŸ˜«"));
    let mut host: String = String::new();
    let mut bonafide: String = String::new();
    let mut rng = rand::thread_rng();

    /*
     * BONAFIDE is a global variable randomally generated by the server and expected
     * in the header of any requests sent to the server. This is used as a very simple
     * security measure to ensure only internal requests are accepted.
     */
    unsafe {
        BONAFIDE = format!("{}", rng.gen_range(0..65535));
    }

    /*
     * Next we will open up our in-memory sqlite database which will eventually be used for lots of things.
     * After opening it we will attach the settings database to it and copy the settings across.
     */
    if let Ok(db) = Connection::open("c:/dev/in_memory.sqlite") {
        // Used for debugging
        //           if let Ok(db) = Connection::open_in_memory() { // Used for production

        ReloadSettings_(&db);
        // Create the table which will hold all of the file names
        db.execute_batch(
            r#"
               DROP TABLE IF EXISTS files;
               CREATE TABLE files (
                    path TEXT NOT NULL UNIQUE, /* Full path to image file */
                    created DATETIME, /* The time file file was created in seconds since Unix epoc */ 
                    orig_file_name TEXT, 
                    new_file_name TEXT,
                    nksc_path TEXT, /* Path to the Nikon sidecar file */
                    inNXstudio BOOL DEFAULT 0, /* has an entry in the NX Studio sqlite database */
                    tmp_lock BOOL DEFAULT 0, /* Temporary lock for internal use */
                    locked BOOL DEFAULT 0 /* Name change manually locked */
                );

                DROP TABLE IF EXISTS exif;
                CREATE TABLE exif (
                    path TEXT NOT NULL, /* Full path to the original image file */
                    tag TEXT NOT NULL, /* An exif TAG shorhand in text, as opposed to ID */
                    tag_id,
                    value TEXT NOT NULL, /* The value of the exif tag */
                
                    UNIQUE(path,tag)
                );
            "#,
        )
        .expect("Setting up the file table failed.");

        /*
         *  Server loop
         */
        for request in server.incoming_requests() {
            // println!("received request! method: {:?}, url: {:?}, headers: {:?}", request.method(), request.url(), request.headers());

            /*
             *  Check the headers sent to us to ensure the request has come from our program and not somewhere else.
             *  We check firstly to see if its come from localhost, then make sure it also has sent the secret bonafide key.
             */
            for header in request.headers() {
                if header.field.as_str() == "Host" {
                    host = header.value.to_string();
                } else if header.field.as_str() == "X-Bonafide" {
                    bonafide = header.value.to_string();
                }
            }

            unsafe {
                if bonafide != BONAFIDE || host != HOST {
                    FailU!("A request to mem_db() came from an UNVERIFIED or UNKNOWN souruce.ðŸ˜²\r\rAborting!");
                    PostThreadMessageA(MAIN_THREAD_ID, WM_QUIT, WPARAM(1), LPARAM(0));
                    panic!("mem_db() terminated after receiving a request from an unknown or foriegn source.ðŸ˜¤");
                }
            }

            // Extract our command from the http request
            let command = decode(request.url().trim_start_matches('/')).unwrap();
            let mut response = Response::from_string("Not cool");

            /*
             *  Run our loop to process commands
             *  These ideally should be kind of sorted from largest command string to smallest just
             *  in case there is some overlap in the beginning of the strings.
             */
            if command.starts_with("GetIntSetting") {
                let cmd = format!("SELECT value FROM settings where ID={}", command.get(14..).expect("Extracting ID failed."));
                let mut stmt = db.prepare(&cmd).unwrap();
                let answer = stmt.query_row([], |row| row.get(0) as Result<u32>).expect("No results?");
                response = Response::from_string(format!("{}", answer));
                //
            } else if command.starts_with("SetIntSetting") {
                let value_delimeter = command.rfind('=').unwrap();
                let value = command.get(value_delimeter + 1..).unwrap();
                let id = command.get(14..value_delimeter).unwrap();
                let cmd = format!("UPDATE settings SET value={} WHERE id={};", value, id);
                db.execute(&cmd, []).expect("SetIntSetting() failed.");
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("GetTextSetting") {
                let cmd = format!("SELECT value FROM settings where ID={}", command.get(14..).expect("Extracting ID failed."));
                let mut stmt = db.prepare(&cmd).unwrap();
                let answer = stmt.query_row([], |row| row.get(0) as Result<String>).expect("No results?");
                response = Response::from_string(answer.to_string());
                //
            } else if command.starts_with("SetTextSetting") {
                let value_delimeter = command.rfind('=').unwrap();
                let value = command.get(value_delimeter + 1..).unwrap();
                let id = command.get(15..value_delimeter).unwrap();
                let cmd = format!("UPDATE settings SET value='{}' WHERE id={};", value, id);
                db.execute(&cmd, []).expect("SetTextSetting() failed.");
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("SaveSettings") {
                SaveSettings_(&db);
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("ReloadSettings") {
                ReloadSettings_(&db);
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("Count") {
                let table_delimeter = command.rfind('=').unwrap();
                let table = command.get(table_delimeter + 1..).unwrap();
                let what = command.get(6..table_delimeter).unwrap();
                let cmd = format!("SELECT COUNT( DISTINCT {}) FROM {};", what, table);
                let mut stmt = db.prepare(&cmd).unwrap();
                let answer = stmt.query_row([], |row| row.get(0) as Result<u32>).expect("No results?");
                response = Response::from_string(format!("{}", answer));
                //
            } else if command.starts_with("GetFilePatterns") {
                let idx = command.get(16..).unwrap();
                let cmd = format!("SELECT pszName, pszSpec FROM file_pat WHERE idx={};", idx);
                let mut stmt = db.prepare(&cmd).unwrap();
                let pszName = stmt.query_row([], |row| row.get(0) as Result<String>).expect("No results?");
                let pszSpec = stmt.query_row([], |row| row.get(1) as Result<String>).expect("No results?");
                response = Response::from_string(format!("{}&{}", pszName, pszSpec));
                //
            } else if command.starts_with("DeleteFilePattern") {
                let pszName = command.get(18..).unwrap();
                let cmd = format!("DELETE FROM file_pat WHERE pszName='{}';", pszName);
                db.execute(&cmd, []).expect("DeleteFilePattern() failed.");
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("MakeTempFilePatternDatabase") {
                let cmd = "DROP TABLE IF EXISTS tmp_file_pat; CREATE TABLE tmp_file_pat AS SELECT * FROM file_pat;".to_string();
                db.execute_batch(&cmd).expect("MakeTempFilePatternDatabase() failed.");
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("RestoreFilePatternDatabase") {
                let cmd = r#"DROP TABLE IF EXISTS file_pat;
                                      CREATE TABLE 'file_pat' 
                                      (
                                          idx INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE, 
                                          pszName TEXT,
                                          pszSpec TEXT
                                      );
                                      INSERT INTO file_pat (pszName, pszSpec) SELECT pszName, pszSpec FROM tmp_file_pat;
                                      DROP TABLE IF EXISTS tmp_file_pat"#
                    .to_string();
                db.execute_batch(&cmd).expect("RestoreFilePatternDatabase() failed.");
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("AddFilePattern") {
                let idx_delimeter = command.find('=').unwrap();
                let zName_delimeter = command.rfind("|+|").unwrap();
                let zSpec_delimeter = command.rfind("|$|").unwrap();
                let idx = command.get(idx_delimeter + 1..zName_delimeter).unwrap();
                let zName = command.get(zName_delimeter + 3..zSpec_delimeter - 1).unwrap();
                let zSpec = command.get(zSpec_delimeter + 3..command.len() - 1).unwrap();

                let cmd = format!(
                    r#"
                DROP TABLE IF EXISTS add_file_pat;
                CREATE TABLE add_file_pat 
                (
                    idx INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE, 
                    pszName TEXT,
                    pszSpec TEXT
                );
                INSERT INTO add_file_pat (pszName, pszSpec) SELECT pszName, pszSpec FROM file_pat WHERE idx <={idx};
                INSERT INTO add_file_pat (pszName, pszSpec) VALUES ('{zName}', '{zSpec}');
                INSERT INTO add_file_pat (pszName, pszSpec) SELECT pszName, pszSpec FROM file_pat WHERE idx >{idx};
                DROP TABLE IF EXISTS file_pat;
                ALTER TABLE add_file_pat RENAME TO file_pat;
                "#,
                    idx = idx,
                    zName = zName,
                    zSpec = zSpec
                );
                db.execute_batch(&cmd).expect("AddFilePattern() failed.");
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("QuickNonReturningSqlCommand") {
                let cmd = command.get(28..command.len() - 1).unwrap();
                db.execute_batch(cmd).expect("QuickNonReturningSqlCommand() failed.");
                response = Response::from_string("Okay");
                //
            } else if command.starts_with("GetFileSpec") {
                let idx = command.get(12..).unwrap();
                let cmd = format!(
                    r#"
                                            SELECT pszSpec FROM file_pat 
                                              WHERE
                                               idx=(SELECT idx FROM file_pat,settings 
                                                        WHERE 
                                                          file_pat.idx=(settings.value + 1) 
                                                          AND id={} 
                                                          AND file_pat.idx
                                                        );               
                                        "#,
                    idx
                );

                let mut stmt = db.prepare(&cmd).unwrap();
                let pszSpec = stmt.query_row([], |row| row.get(0) as Result<String>).expect("No results?");
                response = Response::from_string(pszSpec.to_string());
                //
            } else if command.starts_with("Quit") {
                println!("Quit");
                unsafe {
                    PostThreadMessageA(MAIN_THREAD_ID, WM_QUIT, WPARAM(2), LPARAM(0));
                }

                //
            }

            // Generate a new key for the next request
            unsafe {
                BONAFIDE = format!("{}", rng.gen_range(0..65535));
            }
            request.respond(response).unwrap();
        }
    } else {
        Fail!("Could not start internal database service. ðŸ˜¯");
    }
}

/// Shorthand function to make the code a little more readable
//
// Twas a bit of a pain to write because both minreq and tinyhttp have the same "Response" name space and
// it took a while to work out what was going wrong!
pub fn send_cmd(cmd: &str, error_msg: &str) -> minreq::Response {
    let cmd = format!("{}/{}", HOST_URL.to_owned(), cmd);
    unsafe { minreq::get(cmd).with_header("X-Bonafide", BONAFIDE.as_str()).send().expect(error_msg) }
}

/// Get an integer value from the settings database
pub fn GetIntSetting(id: i32) -> usize {
    let cmd = format!("GetIntSetting={}", id);
    send_cmd(&cmd, "GetIntSetting() failed").as_str().unwrap().parse::<usize>().unwrap()
}

/// Set an integer value from the settings database
pub fn SetIntSetting(id: i32, value: isize) {
    let cmd = format!("SetIntSetting={}={}", id, value);
    send_cmd(&cmd, "SetIntSetting() failed");
}

/// Get a TEXT value from the settings database
pub fn GetTextSetting(id: i32) -> String {
    let cmd = format!("GetTextSetting={}", id);
    let answer = send_cmd(&cmd, "GetTextSetting() failed");
    let answer = answer.as_str().unwrap();
    answer.to_string()
}

/// Set a TEXT value in the settings database
pub fn SetTextSetting(id: i32, value: String) {
    let cmd = format!("SetTextSetting={}={}", id, value);
    send_cmd(&cmd, "SetTextSetting() failed");
}

/// Wrapper function to reload settings database from disc
pub fn ReloadSettings() {
    send_cmd("ReloadSettings", "ReloadSettings() failed");
}

/// Function to reload the settings database from disc
fn ReloadSettings_(db: &Connection) {
    unsafe {
        let cmd = format!(
            r#"DROP TABLE IF EXISTS 'settings';
            CREATE TABLE 'settings' (name,ID,value);
            DROP TABLE IF EXISTS file_pat;
            CREATE TABLE 'file_pat' 
              (
                idx INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE, 
                pszName TEXT,
                pszSpec TEXT
              );
            ATTACH DATABASE '{}' AS SETTINGS;
              INSERT INTO main.settings SELECT * FROM settings.settings;
              INSERT INTO file_pat (pszName, pszSpec) SELECT pszName, pszSpec FROM settings.load_filterspec;
            DETACH DATABASE SETTINGS;"#,
            path_to_settings_sqlite
        );
        db.execute_batch(&cmd).expect("ReloadSettings_() failed.");
    }
}

/// Save the settings to disc
pub fn SaveSettings() {
    send_cmd("SaveSettings", "SaveSettings() failed");
}

/// Function to save the settings to disc
fn SaveSettings_(db: &Connection) {
    unsafe {
        let cmd = format!(
            r#"ATTACH DATABASE '{}' AS SETTINGS;
            DELETE FROM settings.settings WHERE id IN (SELECT id FROM main.settings);
            INSERT INTO settings.settings SELECT * FROM main.settings;
            DROP TABLE settings.load_filterspec;
            CREATE TABLE settings.load_filterspec (idx INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE, pszName TEXT, pszSpec TEXT);
            INSERT INTO settings.load_filterspec (pszName, pszSpec) SELECT pszName, pszSpec FROM main.file_pat ORDER BY idx;
            DETACH DATABASE SETTINGS"#,
            path_to_settings_sqlite
        );
        db.execute_batch(&cmd).expect("SaveSettings_() failed.");
    }
}

/// Transfer settings from the dialog boxes in the preferences screen to the in memory settings database
pub fn ApplySettings(hwnd: HWND) {
    unsafe {
        SetIntSetting(IDC_PREFS_ON_CONFLICT, SendDlgItemMessageA(hwnd, IDC_PREFS_ON_CONFLICT, CB_GETCURSEL, WPARAM(0), LPARAM(0)).0);
        SetIntSetting(IDC_PREFS_ON_CONFLICT_ADD, SendDlgItemMessageA(hwnd, IDC_PREFS_ON_CONFLICT_ADD, CB_GETCURSEL, WPARAM(0), LPARAM(0)).0);
        SetIntSetting(IDC_PREFS_ON_CONFLICT_NUM, SendDlgItemMessageA(hwnd, IDC_PREFS_ON_CONFLICT_NUM, CB_GETCURSEL, WPARAM(0), LPARAM(0)).0);
        SetIntSetting(IDC_PREFS_DATE_SHOOT_PRIMARY, SendDlgItemMessageA(hwnd, IDC_PREFS_DATE_SHOOT_PRIMARY, CB_GETCURSEL, WPARAM(0), LPARAM(0)).0);
        SetIntSetting(IDC_PREFS_DATE_SHOOT_SECONDARY, SendDlgItemMessageA(hwnd, IDC_PREFS_DATE_SHOOT_SECONDARY, CB_GETCURSEL, WPARAM(0), LPARAM(0)).0);
        SetIntSetting(IDC_PREFS_DRAG_N_DROP, SendDlgItemMessageA(hwnd, IDC_PREFS_DRAG_N_DROP, CB_GETCURSEL, WPARAM(0), LPARAM(0)).0);
        SetIntSetting(IDC_PREFS_EXIF_Engine, SendDlgItemMessageA(hwnd, IDC_PREFS_EXIF_Engine, CB_GETCURSEL, WPARAM(0), LPARAM(0)).0);
        let mut tmp_text: [u16; MAX_PATH as usize] = [0; MAX_PATH as usize];
        let len = GetWindowTextW(GetDlgItem(hwnd, IDC_PREFS_ExifToolPath), &mut tmp_text);
        let exif_tool_path = String::from_utf16_lossy(&tmp_text[..len as usize]);
        SetTextSetting(IDC_PREFS_ExifToolPath, exif_tool_path);
        SetIntSetting(IDC_PREFS_NX_STUDIO, IsDlgButtonChecked(hwnd, IDC_PREFS_NX_STUDIO).try_into().unwrap());
    }
}

/// Counts the number of <what>s in a <table> which resides in our in memory database
pub fn Count(what: &str, table: &str) -> usize {
    let cmd = format!("Count={}={}", what, table);
    send_cmd(&cmd, "Count() failed").as_str().unwrap().parse::<usize>().unwrap()
}

/// Gets file masks/patterns from our in memory database
pub fn GetFilePatterns(idx: usize, zName: &mut String, zSpec: &mut String) {
    let cmd = format!("GetFilePatterns={}", idx);
    let answer = send_cmd(&cmd, "GetFilePatterns() failed");
    let answer = answer.as_str().unwrap();
    let delimeter = answer.rfind('&').unwrap();
    *zName = answer.get(..delimeter).unwrap().to_string();
    *zSpec = answer.get(delimeter + 1..).unwrap().to_string();
}

/// Gets file speccs from our in memory database
pub fn GetFileSpec(idx: usize, zSpec: &mut String) {
    let cmd = format!("GetFileSpec={}", idx);
    let answer = send_cmd(&cmd, "GetFileSpec() failed");
    let answer = answer.as_str().unwrap();
    *zSpec = answer.to_string();
}

/// Deletes a file masks/patterns from our in memory database
pub fn DeleteFilePattern(zName: &mut String) {
    let cmd = format!("DeleteFilePattern={}", zName);
    send_cmd(&cmd, "DeleteFilePattern() failed");
}

/// Makes a temporary copy of the file pattern table in our in-memory database
pub fn MakeTempFilePatternDatabase() {
    send_cmd("MakeTempFilePatternDatabase", "MakeTempFilePatternDatabase() failed");
}

/// Restores the default file patterns
pub fn RestoreFilePatternDatabase() {
    send_cmd("RestoreFilePatternDatabase", "RestoreFilePatternDatabase() failed");
}

/// Gets file masks/patterns from our in memory database
pub fn AddFilePattern(idx: usize, zName: String, zSpec: String) {
    let cmd = format!("AddFilePattern={}|+|{}|$|{}", idx, zName, zSpec);
    send_cmd(&cmd, "AddFilePattern() failed");
}

/// Runs a non-returning batch sql script
pub fn QuickNonReturningSqlCommand(sql: String) {
    let cmd = format!("QuickNonReturningSqlCommand={}", sql);
    send_cmd(&cmd, "QuickNonReturningSqlCommand() failed");
}
